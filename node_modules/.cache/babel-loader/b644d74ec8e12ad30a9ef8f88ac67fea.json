{"ast":null,"code":"const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n};\n\nfunction assert(cond, msg) {\n  if (!cond) throw new Error(msg);\n}\n\nfunction isUint8Array(name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ');\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;\n      assert(length.includes(value.length), msg);\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`;\n      assert(value.length === length, msg);\n    }\n  }\n}\n\nfunction isCompressed(value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');\n}\n\nfunction getAssertedOutput() {\n  let output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : len => new Uint8Array(len);\n  let length = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof output === 'function') output = output(length);\n  isUint8Array('output', output, length);\n  return output;\n}\n\nfunction toTypeString(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\n\nmodule.exports = secp256k1 => {\n  return {\n    contextRandomize(seed) {\n      assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');\n      if (seed !== null) isUint8Array('seed', seed, 32);\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);\n      }\n    },\n\n    privateKeyVerify(seckey) {\n      isUint8Array('private key', seckey, 32);\n      return secp256k1.privateKeyVerify(seckey) === 0;\n    },\n\n    privateKeyNegate(seckey) {\n      isUint8Array('private key', seckey, 32);\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    privateKeyTweakAdd(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n\n    privateKeyTweakMul(seckey, tweak) {\n      isUint8Array('private key', seckey, 32);\n      isUint8Array('tweak', tweak, 32);\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey;\n\n        case 1:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n\n    publicKeyVerify(pubkey) {\n      isUint8Array('public key', pubkey, [33, 65]);\n      return secp256k1.publicKeyVerify(pubkey) === 0;\n    },\n\n    publicKeyCreate(seckey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('private key', seckey, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SECKEY_INVALID);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyConvert(pubkey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyNegate(pubkey) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyCombine(pubkeys) {\n      let compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      let output = arguments.length > 2 ? arguments[2] : undefined;\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');\n\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65]);\n      }\n\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE);\n\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE);\n      }\n    },\n\n    publicKeyTweakAdd(pubkey, tweak) {\n      let compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_ADD);\n      }\n    },\n\n    publicKeyTweakMul(pubkey, tweak) {\n      let compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('tweak', tweak, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.TWEAK_MUL);\n      }\n    },\n\n    signatureNormalize(sig) {\n      isUint8Array('signature', sig, 64);\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n      }\n    },\n\n    signatureExport(sig, output) {\n      isUint8Array('signature', sig, 64);\n      output = getAssertedOutput(output, 72);\n      const obj = {\n        output,\n        outputlen: 72\n      };\n\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen);\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    signatureImport(sig, output) {\n      isUint8Array('signature', sig);\n      output = getAssertedOutput(output, 64);\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdsaSign(msg32, seckey) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('message', msg32, 32);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');\n      output = getAssertedOutput(output, 64);\n      const obj = {\n        signature: output,\n        recid: null\n      };\n\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj;\n\n        case 1:\n          throw new Error(errors.SIGN);\n\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdsaVerify(sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64);\n      isUint8Array('message', msg32, 32);\n      isUint8Array('public key', pubkey, [33, 65]);\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true;\n\n        case 3:\n          return false;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE);\n      }\n    },\n\n    ecdsaRecover(sig, recid, msg32) {\n      let compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      let output = arguments.length > 4 ? arguments[4] : undefined;\n      isUint8Array('signature', sig, 64);\n      assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');\n      isUint8Array('message', msg32, 32);\n      isCompressed(compressed);\n      output = getAssertedOutput(output, compressed ? 33 : 65);\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.SIG_PARSE);\n\n        case 2:\n          throw new Error(errors.RECOVER);\n\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE);\n      }\n    },\n\n    ecdh(pubkey, seckey) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      let output = arguments.length > 3 ? arguments[3] : undefined;\n      isUint8Array('public key', pubkey, [33, 65]);\n      isUint8Array('private key', seckey, 32);\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object');\n      if (options.data !== undefined) isUint8Array('options.data', options.data);\n\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);\n        isUint8Array('output', output);\n      } else {\n        output = getAssertedOutput(output, 32);\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output;\n\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE);\n\n        case 2:\n          throw new Error(errors.ECDH);\n      }\n    }\n\n  };\n};","map":{"version":3,"names":["errors","IMPOSSIBLE_CASE","TWEAK_ADD","TWEAK_MUL","CONTEXT_RANDOMIZE_UNKNOW","SECKEY_INVALID","PUBKEY_PARSE","PUBKEY_SERIALIZE","PUBKEY_COMBINE","SIG_PARSE","SIGN","RECOVER","ECDH","assert","cond","msg","Error","isUint8Array","name","value","length","Uint8Array","undefined","Array","isArray","numbers","join","includes","isCompressed","toTypeString","getAssertedOutput","output","len","Object","prototype","toString","call","slice","module","exports","secp256k1","contextRandomize","seed","privateKeyVerify","seckey","privateKeyNegate","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyVerify","pubkey","publicKeyCreate","compressed","publicKeyConvert","publicKeyNegate","publicKeyCombine","pubkeys","publicKeyTweakAdd","publicKeyTweakMul","signatureNormalize","sig","signatureExport","obj","outputlen","signatureImport","ecdsaSign","msg32","options","data","noncefn","signature","recid","ecdsaVerify","ecdsaRecover","ecdh","hashfn","xbuf","ybuf"],"sources":["C:/Users/Lenovo/Desktop/OpenSea web3/my-app/node_modules/secp256k1/lib/index.js"],"sourcesContent":["const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}