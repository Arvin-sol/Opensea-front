{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message, fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value !== undefined) {\n    params.value = value;\n  }\n\n  return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n} // Constant to pull zeros from for multipliers\n\n\nlet zeros = \"0\";\n\nwhile (zeros.length < 256) {\n  zeros += zeros;\n} // Returns a string \"1\" followed by decimal \"0\"s\n\n\nfunction getMultiplier(decimals) {\n  if (typeof decimals !== \"number\") {\n    try {\n      decimals = BigNumber.from(decimals).toNumber();\n    } catch (e) {}\n  }\n\n  if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n    return \"1\" + zeros.substring(0, decimals);\n  }\n\n  return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  const multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)\n\n  value = BigNumber.from(value);\n  const negative = value.lt(Zero);\n\n  if (negative) {\n    value = value.mul(NegativeOne);\n  }\n\n  let fraction = value.mod(multiplier).toString();\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction = \"0\" + fraction;\n  } // Strip training 0\n\n\n  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n  const whole = value.div(multiplier).toString();\n\n  if (multiplier.length === 1) {\n    value = whole;\n  } else {\n    value = whole + \".\" + fraction;\n  }\n\n  if (negative) {\n    value = \"-\" + value;\n  }\n\n  return value;\n}\nexport function parseFixed(value, decimals) {\n  if (decimals == null) {\n    decimals = 0;\n  }\n\n  const multiplier = getMultiplier(decimals);\n\n  if (typeof value !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n    logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n  } // Is it negative?\n\n\n  const negative = value.substring(0, 1) === \"-\";\n\n  if (negative) {\n    value = value.substring(1);\n  }\n\n  if (value === \".\") {\n    logger.throwArgumentError(\"missing value\", \"value\", value);\n  } // Split it into a whole and fractional part\n\n\n  const comps = value.split(\".\");\n\n  if (comps.length > 2) {\n    logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n  }\n\n  let whole = comps[0],\n      fraction = comps[1];\n\n  if (!whole) {\n    whole = \"0\";\n  }\n\n  if (!fraction) {\n    fraction = \"0\";\n  } // Trim trailing zeros\n\n\n  while (fraction[fraction.length - 1] === \"0\") {\n    fraction = fraction.substring(0, fraction.length - 1);\n  } // Check the fraction doesn't exceed our decimals size\n\n\n  if (fraction.length > multiplier.length - 1) {\n    throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n  } // If decimals is 0, we have an empty string for fraction\n\n\n  if (fraction === \"\") {\n    fraction = \"0\";\n  } // Fully pad the string with zeros to get to wei\n\n\n  while (fraction.length < multiplier.length - 1) {\n    fraction += \"0\";\n  }\n\n  const wholeValue = BigNumber.from(whole);\n  const fractionValue = BigNumber.from(fraction);\n  let wei = wholeValue.mul(multiplier).add(fractionValue);\n\n  if (negative) {\n    wei = wei.mul(NegativeOne);\n  }\n\n  return wei;\n}\nexport class FixedFormat {\n  constructor(constructorGuard, signed, width, decimals) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.signed = signed;\n    this.width = width;\n    this.decimals = decimals;\n    this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    this._multiplier = getMultiplier(decimals);\n    Object.freeze(this);\n  }\n\n  static from(value) {\n    if (value instanceof FixedFormat) {\n      return value;\n    }\n\n    if (typeof value === \"number\") {\n      value = `fixed128x${value}`;\n    }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof value === \"string\") {\n      if (value === \"fixed\") {// defaults...\n      } else if (value === \"ufixed\") {\n        signed = false;\n      } else {\n        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\n        if (!match) {\n          logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n        }\n\n        signed = match[1] !== \"u\";\n        width = parseInt(match[2]);\n        decimals = parseInt(match[3]);\n      }\n    } else if (value) {\n      const check = (key, type, defaultValue) => {\n        if (value[key] == null) {\n          return defaultValue;\n        }\n\n        if (typeof value[key] !== type) {\n          logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n        }\n\n        return value[key];\n      };\n\n      signed = check(\"signed\", \"boolean\", signed);\n      width = check(\"width\", \"number\", width);\n      decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n    }\n\n    if (decimals > 80) {\n      logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n    }\n\n    return new FixedFormat(_constructorGuard, signed, width, decimals);\n  }\n\n}\nexport class FixedNumber {\n  constructor(constructorGuard, hex, value, format) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new FixedFormat\"\n      });\n    }\n\n    this.format = format;\n    this._hex = hex;\n    this._value = value;\n    this._isFixedNumber = true;\n    Object.freeze(this);\n  }\n\n  _checkFormat(other) {\n    if (this.format.name !== other.format.name) {\n      logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n  }\n\n  addUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n  }\n\n  subUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n  }\n\n  mulUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n  }\n\n  divUnsafe(other) {\n    this._checkFormat(other);\n\n    const a = parseFixed(this._value, this.format.decimals);\n    const b = parseFixed(other._value, other.format.decimals);\n    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n  }\n\n  floor() {\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n\n    if (this.isNegative() && hasFraction) {\n      result = result.subUnsafe(ONE.toFormat(result.format));\n    }\n\n    return result;\n  }\n\n  ceiling() {\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    let result = FixedNumber.from(comps[0], this.format);\n    const hasFraction = !comps[1].match(/^(0*)$/);\n\n    if (!this.isNegative() && hasFraction) {\n      result = result.addUnsafe(ONE.toFormat(result.format));\n    }\n\n    return result;\n  } // @TODO: Support other rounding algorithms\n\n\n  round(decimals) {\n    if (decimals == null) {\n      decimals = 0;\n    } // If we are already in range, we're done\n\n\n    const comps = this.toString().split(\".\");\n\n    if (comps.length === 1) {\n      comps.push(\"0\");\n    }\n\n    if (decimals < 0 || decimals > 80 || decimals % 1) {\n      logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n    }\n\n    if (comps[1].length <= decimals) {\n      return this;\n    }\n\n    const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n    const bump = BUMP.toFormat(this.format);\n    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n  }\n\n  isZero() {\n    return this._value === \"0.0\" || this._value === \"0\";\n  }\n\n  isNegative() {\n    return this._value[0] === \"-\";\n  }\n\n  toString() {\n    return this._value;\n  }\n\n  toHexString(width) {\n    if (width == null) {\n      return this._hex;\n    }\n\n    if (width % 8) {\n      logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n    }\n\n    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n    return hexZeroPad(hex, width / 8);\n  }\n\n  toUnsafeFloat() {\n    return parseFloat(this.toString());\n  }\n\n  toFormat(format) {\n    return FixedNumber.fromString(this._value, format);\n  }\n\n  static fromValue(value, decimals, format) {\n    // If decimals looks more like a format, and there is no format, shift the parameters\n    if (format == null && decimals != null && !isBigNumberish(decimals)) {\n      format = decimals;\n      decimals = null;\n    }\n\n    if (decimals == null) {\n      decimals = 0;\n    }\n\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n  }\n\n  static fromString(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    const fixedFormat = FixedFormat.from(format);\n    const numeric = parseFixed(value, fixedFormat.decimals);\n\n    if (!fixedFormat.signed && numeric.lt(Zero)) {\n      throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n    }\n\n    let hex = null;\n\n    if (fixedFormat.signed) {\n      hex = numeric.toTwos(fixedFormat.width).toHexString();\n    } else {\n      hex = numeric.toHexString();\n      hex = hexZeroPad(hex, fixedFormat.width / 8);\n    }\n\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n\n  static fromBytes(value, format) {\n    if (format == null) {\n      format = \"fixed\";\n    }\n\n    const fixedFormat = FixedFormat.from(format);\n\n    if (arrayify(value).length > fixedFormat.width / 8) {\n      throw new Error(\"overflow\");\n    }\n\n    let numeric = BigNumber.from(value);\n\n    if (fixedFormat.signed) {\n      numeric = numeric.fromTwos(fixedFormat.width);\n    }\n\n    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n    const decimal = formatFixed(numeric, fixedFormat.decimals);\n    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n  }\n\n  static from(value, format) {\n    if (typeof value === \"string\") {\n      return FixedNumber.fromString(value, format);\n    }\n\n    if (isBytes(value)) {\n      return FixedNumber.fromBytes(value, format);\n    }\n\n    try {\n      return FixedNumber.fromValue(value, 0, format);\n    } catch (error) {\n      // Allow NUMERIC_FAULT to bubble up\n      if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n        throw error;\n      }\n    }\n\n    return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n  }\n\n  static isFixedNumber(value) {\n    return !!(value && value._isFixedNumber);\n  }\n\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");","map":{"version":3,"sources":["../src.ts/fixednumber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexport function parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexport class FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nexport class FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map"]},"metadata":{},"sourceType":"module"}