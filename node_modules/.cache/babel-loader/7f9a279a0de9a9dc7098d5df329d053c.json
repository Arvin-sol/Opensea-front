{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n\n(function (TransactionTypes) {\n  TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n  TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n  TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n\n; ///////////////////////////////\n\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n\n  return getAddress(value);\n}\n\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n\n  return BigNumber.from(value);\n} // Legacy Transaction Fields\n\n\nconst transactionFields = [{\n  name: \"nonce\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasPrice\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasLimit\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"to\",\n  length: 20\n}, {\n  name: \"value\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"data\"\n}];\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  type: true,\n  value: true\n};\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value, name) {\n  const result = stripZeros(BigNumber.from(value).toHexString());\n\n  if (result.length > 32) {\n    logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n  }\n\n  return result;\n}\n\nfunction accessSetify(addr, storageKeys) {\n  return {\n    address: getAddress(addr),\n    storageKeys: (storageKeys || []).map((storageKey, index) => {\n      if (hexDataLength(storageKey) !== 32) {\n        logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n      }\n\n      return storageKey.toLowerCase();\n    })\n  };\n}\n\nexport function accessListify(value) {\n  if (Array.isArray(value)) {\n    return value.map((set, index) => {\n      if (Array.isArray(set)) {\n        if (set.length > 2) {\n          logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n        }\n\n        return accessSetify(set[0], set[1]);\n      }\n\n      return accessSetify(set.address, set.storageKeys);\n    });\n  }\n\n  const result = Object.keys(value).map(addr => {\n    const storageKeys = value[addr].reduce((accum, storageKey) => {\n      accum[storageKey] = true;\n      return accum;\n    }, {});\n    return accessSetify(addr, Object.keys(storageKeys).sort());\n  });\n  result.sort((a, b) => a.address.localeCompare(b.address));\n  return result;\n}\n\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\n\nfunction _serializeEip1559(transaction, signature) {\n  // If there is an explicit gasPrice, make sure it matches the\n  // EIP-1559 fees; otherwise they may not understand what they\n  // think they are setting in terms of fee.\n  if (transaction.gasPrice != null) {\n    const gasPrice = BigNumber.from(transaction.gasPrice);\n    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n\n    if (!gasPrice.eq(maxFeePerGas)) {\n      logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n        gasPrice,\n        maxFeePerGas\n      });\n    }\n  }\n\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n\n  return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction, signature) {\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.gasPrice || 0, \"gasPrice\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n\n  return hexConcat([\"0x01\", RLP.encode(fields)]);\n} // Legacy Transactions and EIP-155\n\n\nfunction _serialize(transaction, signature) {\n  checkProperties(transaction, allowedTransactionKeys);\n  const raw = [];\n  transactionFields.forEach(function (fieldInfo) {\n    let value = transaction[fieldInfo.name] || [];\n    const options = {};\n\n    if (fieldInfo.numeric) {\n      options.hexPad = \"left\";\n    }\n\n    value = arrayify(hexlify(value, options)); // Fixed-width field\n\n    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n      logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n    } // Variable-width (with a maximum)\n\n\n    if (fieldInfo.maxLength) {\n      value = stripZeros(value);\n\n      if (value.length > fieldInfo.maxLength) {\n        logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n      }\n    }\n\n    raw.push(hexlify(value));\n  });\n  let chainId = 0;\n\n  if (transaction.chainId != null) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = transaction.chainId;\n\n    if (typeof chainId !== \"number\") {\n      logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n    }\n  } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n    // No chainId provided, but the signature is signing with EIP-155; derive chainId\n    chainId = Math.floor((signature.v - 35) / 2);\n  } // We have an EIP-155 transaction (chainId was specified and non-zero)\n\n\n  if (chainId !== 0) {\n    raw.push(hexlify(chainId)); // @TODO: hexValue?\n\n    raw.push(\"0x\");\n    raw.push(\"0x\");\n  } // Requesting an unsigned transaction\n\n\n  if (!signature) {\n    return RLP.encode(raw);\n  } // The splitSignature will ensure the transaction has a recoveryParam in the\n  // case that the signTransaction function only adds a v.\n\n\n  const sig = splitSignature(signature); // We pushed a chainId and null r, s on for hashing only; remove those\n\n  let v = 27 + sig.recoveryParam;\n\n  if (chainId !== 0) {\n    raw.pop();\n    raw.pop();\n    raw.pop();\n    v += chainId * 2 + 8; // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\n    if (sig.v > 28 && sig.v !== v) {\n      logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n  } else if (sig.v !== v) {\n    logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n  }\n\n  raw.push(hexlify(v));\n  raw.push(stripZeros(arrayify(sig.r)));\n  raw.push(stripZeros(arrayify(sig.s)));\n  return RLP.encode(raw);\n}\n\nexport function serialize(transaction, signature) {\n  // Legacy and EIP-155 Transactions\n  if (transaction.type == null || transaction.type === 0) {\n    if (transaction.accessList != null) {\n      logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n    }\n\n    return _serialize(transaction, signature);\n  } // Typed Transactions (EIP-2718)\n\n\n  switch (transaction.type) {\n    case 1:\n      return _serializeEip2930(transaction, signature);\n\n    case 2:\n      return _serializeEip1559(transaction, signature);\n\n    default:\n      break;\n  }\n\n  return logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"serializeTransaction\",\n    transactionType: transaction.type\n  });\n}\n\nfunction _parseEipSignature(tx, fields, serialize) {\n  try {\n    const recid = handleNumber(fields[0]).toNumber();\n\n    if (recid !== 0 && recid !== 1) {\n      throw new Error(\"bad recid\");\n    }\n\n    tx.v = recid;\n  } catch (error) {\n    logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n  }\n\n  tx.r = hexZeroPad(fields[1], 32);\n  tx.s = hexZeroPad(fields[2], 32);\n\n  try {\n    const digest = keccak256(serialize(tx));\n    tx.from = recoverAddress(digest, {\n      r: tx.r,\n      s: tx.s,\n      recoveryParam: tx.v\n    });\n  } catch (error) {}\n}\n\nfunction _parseEip1559(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n\n  if (transaction.length !== 9 && transaction.length !== 12) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n  }\n\n  const maxPriorityFeePerGas = handleNumber(transaction[2]);\n  const maxFeePerGas = handleNumber(transaction[3]);\n  const tx = {\n    type: 2,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleNumber(transaction[4]),\n    to: handleAddress(transaction[5]),\n    value: handleNumber(transaction[6]),\n    data: transaction[7],\n    accessList: accessListify(transaction[8])\n  }; // Unsigned EIP-1559 Transaction\n\n  if (transaction.length === 9) {\n    return tx;\n  }\n\n  tx.hash = keccak256(payload);\n\n  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n  return tx;\n}\n\nfunction _parseEip2930(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n\n  if (transaction.length !== 8 && transaction.length !== 11) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n  }\n\n  const tx = {\n    type: 1,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    gasPrice: handleNumber(transaction[2]),\n    gasLimit: handleNumber(transaction[3]),\n    to: handleAddress(transaction[4]),\n    value: handleNumber(transaction[5]),\n    data: transaction[6],\n    accessList: accessListify(transaction[7])\n  }; // Unsigned EIP-2930 Transaction\n\n  if (transaction.length === 8) {\n    return tx;\n  }\n\n  tx.hash = keccak256(payload);\n\n  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n  return tx;\n} // Legacy Transactions and EIP-155\n\n\nfunction _parse(rawTransaction) {\n  const transaction = RLP.decode(rawTransaction);\n\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n  }\n\n  const tx = {\n    nonce: handleNumber(transaction[0]).toNumber(),\n    gasPrice: handleNumber(transaction[1]),\n    gasLimit: handleNumber(transaction[2]),\n    to: handleAddress(transaction[3]),\n    value: handleNumber(transaction[4]),\n    data: transaction[5],\n    chainId: 0\n  }; // Legacy unsigned transaction\n\n  if (transaction.length === 6) {\n    return tx;\n  }\n\n  try {\n    tx.v = BigNumber.from(transaction[6]).toNumber();\n  } catch (error) {\n    // @TODO: What makes snese to do? The v is too big\n    return tx;\n  }\n\n  tx.r = hexZeroPad(transaction[7], 32);\n  tx.s = hexZeroPad(transaction[8], 32);\n\n  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.v;\n    tx.v = 0;\n  } else {\n    // Signed Transaction\n    tx.chainId = Math.floor((tx.v - 35) / 2);\n\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n\n    let recoveryParam = tx.v - 27;\n    const raw = transaction.slice(0, 6);\n\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push(\"0x\");\n      raw.push(\"0x\");\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n\n    const digest = keccak256(RLP.encode(raw));\n\n    try {\n      tx.from = recoverAddress(digest, {\n        r: hexlify(tx.r),\n        s: hexlify(tx.s),\n        recoveryParam: recoveryParam\n      });\n    } catch (error) {}\n\n    tx.hash = keccak256(rawTransaction);\n  }\n\n  tx.type = null;\n  return tx;\n}\n\nexport function parse(rawTransaction) {\n  const payload = arrayify(rawTransaction); // Legacy and EIP-155 Transactions\n\n  if (payload[0] > 0x7f) {\n    return _parse(payload);\n  } // Typed Transaction (EIP-2718)\n\n\n  switch (payload[0]) {\n    case 1:\n      return _parseEip2930(payload);\n\n    case 2:\n      return _parseEip1559(payload);\n\n    default:\n      break;\n  }\n\n  return logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"parseTransaction\",\n    transactionType: payload[0]\n  });\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"AAAA;;AAEA,SAAS,UAAT,QAA2B,wBAA3B;AACA,SAAS,SAAT,QAAwC,0BAAxC;AACA,SAAS,QAAT,EAA2C,SAA3C,EAAsD,aAAtD,EAAqE,YAArE,EAAmF,OAAnF,EAA4F,UAA5F,EAAwG,WAAxG,EAAoI,cAApI,EAAoJ,UAApJ,QAAuK,sBAAvK;AACA,SAAS,IAAT,QAAqB,0BAArB;AACA,SAAS,SAAT,QAA0B,0BAA1B;AACA,SAAS,eAAT,QAAgC,2BAAhC;AACA,OAAO,KAAK,GAAZ,MAAqB,oBAArB;AACA,SAAS,gBAAT,EAA2B,gBAA3B,QAAmD,4BAAnD;AAEA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,OAAT,QAAwB,YAAxB;AACA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAYA,OAAA,IAAY,gBAAZ;;AAAA,CAAA,UAAY,gBAAZ,EAA4B;EACxB,gBAAA,CAAA,gBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;EACA,gBAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;EACA,gBAAA,CAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACH,CAJD,EAAY,gBAAgB,KAAhB,gBAAgB,GAAA,EAAA,CAA5B;;AAIC,C,CAqDD;;AAEA,SAAS,aAAT,CAAuB,KAAvB,EAAoC;EAChC,IAAI,KAAK,KAAK,IAAd,EAAoB;IAAE,OAAO,IAAP;EAAc;;EACpC,OAAO,UAAU,CAAC,KAAD,CAAjB;AACH;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAAmC;EAC/B,IAAI,KAAK,KAAK,IAAd,EAAoB;IAAE,OAAO,IAAP;EAAc;;EACpC,OAAO,SAAS,CAAC,IAAV,CAAe,KAAf,CAAP;AACH,C,CAED;;;AACA,MAAM,iBAAiB,GAAG,CACtB;EAAE,IAAI,EAAE,OAAR;EAAoB,SAAS,EAAE,EAA/B;EAAmC,OAAO,EAAE;AAA5C,CADsB,EAEtB;EAAE,IAAI,EAAE,UAAR;EAAoB,SAAS,EAAE,EAA/B;EAAmC,OAAO,EAAE;AAA5C,CAFsB,EAGtB;EAAE,IAAI,EAAE,UAAR;EAAoB,SAAS,EAAE,EAA/B;EAAmC,OAAO,EAAE;AAA5C,CAHsB,EAItB;EAAE,IAAI,EAAE,IAAR;EAAuB,MAAM,EAAE;AAA/B,CAJsB,EAKtB;EAAE,IAAI,EAAE,OAAR;EAAoB,SAAS,EAAE,EAA/B;EAAmC,OAAO,EAAE;AAA5C,CALsB,EAMtB;EAAE,IAAI,EAAE;AAAR,CANsB,CAA1B;AASA,MAAM,sBAAsB,GAAiC;EACzD,OAAO,EAAE,IADgD;EAC1C,IAAI,EAAE,IADoC;EAC9B,QAAQ,EAAE,IADoB;EACd,QAAQ,EAAC,IADK;EACC,KAAK,EAAE,IADR;EACc,EAAE,EAAE,IADlB;EACwB,IAAI,EAAE,IAD9B;EACoC,KAAK,EAAE;AAD3C,CAA7D;AAIA,OAAM,SAAU,cAAV,CAAyB,GAAzB,EAAgD;EAClD,MAAM,SAAS,GAAG,gBAAgB,CAAC,GAAD,CAAlC;EACA,OAAO,UAAU,CAAC,YAAY,CAAC,SAAS,CAAC,YAAY,CAAC,SAAD,EAAY,CAAZ,CAAb,CAAV,EAAwC,EAAxC,CAAb,CAAjB;AACH;AAED,OAAM,SAAU,cAAV,CAAyB,MAAzB,EAA4C,SAA5C,EAAoE;EACtE,OAAO,cAAc,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAD,CAAT,EAAmB,SAAnB,CAAjB,CAArB;AACH;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAA2C,IAA3C,EAAuD;EACnD,MAAM,MAAM,GAAG,UAAU,CAAC,SAAS,CAAC,IAAV,CAAe,KAAf,EAAsB,WAAtB,EAAD,CAAzB;;EACA,IAAI,MAAM,CAAC,MAAP,GAAgB,EAApB,EAAwB;IACpB,MAAM,CAAC,kBAAP,CAA0B,wBAAwB,IAAlD,EAAyD,iBAAiB,IAA1E,EAAiF,KAAjF;EACH;;EACD,OAAO,MAAP;AACH;;AAED,SAAS,YAAT,CAAsB,IAAtB,EAAoC,WAApC,EAA8D;EAC1D,OAAO;IACH,OAAO,EAAE,UAAU,CAAC,IAAD,CADhB;IAEH,WAAW,EAAE,CAAC,WAAW,IAAI,EAAhB,EAAoB,GAApB,CAAwB,CAAC,UAAD,EAAa,KAAb,KAAsB;MACvD,IAAI,aAAa,CAAC,UAAD,CAAb,KAA8B,EAAlC,EAAsC;QAClC,MAAM,CAAC,kBAAP,CAA0B,gCAA1B,EAA4D,cAAe,IAAK,IAAK,KAAM,GAA3F,EAAgG,UAAhG;MACH;;MACD,OAAO,UAAU,CAAC,WAAX,EAAP;IACH,CALY;EAFV,CAAP;AASH;;AAED,OAAM,SAAU,aAAV,CAAwB,KAAxB,EAA4C;EAC9C,IAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;IACtB,OAA0F,KAAM,CAAC,GAAP,CAAW,CAAC,GAAD,EAAM,KAAN,KAAe;MAChH,IAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;QACpB,IAAI,GAAG,CAAC,MAAJ,GAAa,CAAjB,EAAoB;UAChB,MAAM,CAAC,kBAAP,CAA0B,uDAA1B,EAAmF,SAAU,KAAM,GAAnG,EAAwG,GAAxG;QACH;;QACD,OAAO,YAAY,CAAC,GAAG,CAAC,CAAD,CAAJ,EAAS,GAAG,CAAC,CAAD,CAAZ,CAAnB;MACH;;MACD,OAAO,YAAY,CAAC,GAAG,CAAC,OAAL,EAAc,GAAG,CAAC,WAAlB,CAAnB;IACH,CARyF,CAA1F;EASH;;EAED,MAAM,MAAM,GAA2D,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,GAAnB,CAAwB,IAAD,IAAS;IACnG,MAAM,WAAW,GAAyB,KAAK,CAAC,IAAD,CAAL,CAAY,MAAZ,CAAmB,CAAC,KAAD,EAAQ,UAAR,KAAsB;MAC/E,KAAK,CAAC,UAAD,CAAL,GAAoB,IAApB;MACA,OAAO,KAAP;IACH,CAHyC,EAGjB,EAHiB,CAA1C;IAIA,OAAO,YAAY,CAAC,IAAD,EAAO,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,IAAzB,EAAP,CAAnB;EACH,CANsE,CAAvE;EAOA,MAAM,CAAC,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,KAAW,CAAC,CAAC,OAAF,CAAU,aAAV,CAAwB,CAAC,CAAC,OAA1B,CAAvB;EACA,OAAO,MAAP;AACH;;AAED,SAAS,gBAAT,CAA0B,KAA1B,EAA8C;EAC1C,OAAO,aAAa,CAAC,KAAD,CAAb,CAAqB,GAArB,CAA0B,GAAD,IAAS,CAAE,GAAG,CAAC,OAAN,EAAe,GAAG,CAAC,WAAnB,CAAlC,CAAP;AACH;;AAED,SAAS,iBAAT,CAA2B,WAA3B,EAA6D,SAA7D,EAAsF;EAClF;EACA;EACA;EACA,IAAI,WAAW,CAAC,QAAZ,IAAwB,IAA5B,EAAkC;IAC9B,MAAM,QAAQ,GAAG,SAAS,CAAC,IAAV,CAAe,WAAW,CAAC,QAA3B,CAAjB;IACA,MAAM,YAAY,GAAG,SAAS,CAAC,IAAV,CAAe,WAAW,CAAC,YAAZ,IAA4B,CAA3C,CAArB;;IACA,IAAI,CAAC,QAAQ,CAAC,EAAT,CAAY,YAAZ,CAAL,EAAgC;MAC5B,MAAM,CAAC,kBAAP,CAA0B,4CAA1B,EAAwE,IAAxE,EAA8E;QAC1E,QAD0E;QAChE;MADgE,CAA9E;IAGH;EACJ;;EAED,MAAM,MAAM,GAAQ,CAChB,YAAY,CAAC,WAAW,CAAC,OAAZ,IAAuB,CAAxB,EAA2B,SAA3B,CADI,EAEhB,YAAY,CAAC,WAAW,CAAC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAFI,EAGhB,YAAY,CAAC,WAAW,CAAC,oBAAZ,IAAoC,CAArC,EAAwC,sBAAxC,CAHI,EAIhB,YAAY,CAAC,WAAW,CAAC,YAAZ,IAA4B,CAA7B,EAAgC,cAAhC,CAJI,EAKhB,YAAY,CAAC,WAAW,CAAC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CALI,EAMd,WAAW,CAAC,EAAZ,IAAkB,IAAnB,GAA2B,UAAU,CAAC,WAAW,CAAC,EAAb,CAArC,GAAuD,IANxC,EAOhB,YAAY,CAAC,WAAW,CAAC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAPI,EAQf,WAAW,CAAC,IAAZ,IAAoB,IARL,EASf,gBAAgB,CAAC,WAAW,CAAC,UAAZ,IAA0B,EAA3B,CATD,CAApB;;EAYA,IAAI,SAAJ,EAAe;IACX,MAAM,GAAG,GAAG,cAAc,CAAC,SAAD,CAA1B;IACA,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,GAAG,CAAC,aAAL,EAAoB,eAApB,CAAxB;IACA,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,GAAG,CAAC,CAAL,CAAtB;IACA,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,GAAG,CAAC,CAAL,CAAtB;EACH;;EAED,OAAO,SAAS,CAAC,CAAE,MAAF,EAAU,GAAG,CAAC,MAAJ,CAAW,MAAX,CAAV,CAAD,CAAhB;AACH;;AAED,SAAS,iBAAT,CAA2B,WAA3B,EAA6D,SAA7D,EAAsF;EAClF,MAAM,MAAM,GAAQ,CAChB,YAAY,CAAC,WAAW,CAAC,OAAZ,IAAuB,CAAxB,EAA2B,SAA3B,CADI,EAEhB,YAAY,CAAC,WAAW,CAAC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CAFI,EAGhB,YAAY,CAAC,WAAW,CAAC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CAHI,EAIhB,YAAY,CAAC,WAAW,CAAC,QAAZ,IAAwB,CAAzB,EAA4B,UAA5B,CAJI,EAKd,WAAW,CAAC,EAAZ,IAAkB,IAAnB,GAA2B,UAAU,CAAC,WAAW,CAAC,EAAb,CAArC,GAAuD,IALxC,EAMhB,YAAY,CAAC,WAAW,CAAC,KAAZ,IAAqB,CAAtB,EAAyB,OAAzB,CANI,EAOf,WAAW,CAAC,IAAZ,IAAoB,IAPL,EAQf,gBAAgB,CAAC,WAAW,CAAC,UAAZ,IAA0B,EAA3B,CARD,CAApB;;EAWA,IAAI,SAAJ,EAAe;IACX,MAAM,GAAG,GAAG,cAAc,CAAC,SAAD,CAA1B;IACA,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,GAAG,CAAC,aAAL,EAAoB,eAApB,CAAxB;IACA,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,GAAG,CAAC,CAAL,CAAtB;IACA,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,GAAG,CAAC,CAAL,CAAtB;EACH;;EAED,OAAO,SAAS,CAAC,CAAE,MAAF,EAAU,GAAG,CAAC,MAAJ,CAAW,MAAX,CAAV,CAAD,CAAhB;AACH,C,CAED;;;AACA,SAAS,UAAT,CAAoB,WAApB,EAAsD,SAAtD,EAA+E;EAC3E,eAAe,CAAC,WAAD,EAAc,sBAAd,CAAf;EAEA,MAAM,GAAG,GAA+B,EAAxC;EAEA,iBAAiB,CAAC,OAAlB,CAA0B,UAAS,SAAT,EAAkB;IACxC,IAAI,KAAK,GAAS,WAAY,CAAC,SAAS,CAAC,IAAX,CAAZ,IAAiC,EAAnD;IACA,MAAM,OAAO,GAAgB,EAA7B;;IACA,IAAI,SAAS,CAAC,OAAd,EAAuB;MAAE,OAAO,CAAC,MAAR,GAAiB,MAAjB;IAA0B;;IACnD,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAD,EAAQ,OAAR,CAAR,CAAhB,CAJwC,CAMxC;;IACA,IAAI,SAAS,CAAC,MAAV,IAAoB,KAAK,CAAC,MAAN,KAAiB,SAAS,CAAC,MAA/C,IAAyD,KAAK,CAAC,MAAN,GAAe,CAA5E,EAA+E;MAC3E,MAAM,CAAC,kBAAP,CAA0B,wBAAwB,SAAS,CAAC,IAA5D,EAAmE,iBAAiB,SAAS,CAAC,IAA9F,EAAqG,KAArG;IACH,CATuC,CAWxC;;;IACA,IAAI,SAAS,CAAC,SAAd,EAAyB;MACrB,KAAK,GAAG,UAAU,CAAC,KAAD,CAAlB;;MACA,IAAI,KAAK,CAAC,MAAN,GAAe,SAAS,CAAC,SAA7B,EAAwC;QACpC,MAAM,CAAC,kBAAP,CAA0B,wBAAwB,SAAS,CAAC,IAA5D,EAAmE,iBAAiB,SAAS,CAAC,IAA9F,EAAqG,KAArG;MACH;IACJ;;IAED,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,KAAD,CAAhB;EACH,CApBD;EAsBA,IAAI,OAAO,GAAG,CAAd;;EACA,IAAI,WAAW,CAAC,OAAZ,IAAuB,IAA3B,EAAiC;IAC7B;IACA,OAAO,GAAG,WAAW,CAAC,OAAtB;;IAEA,IAAI,OAAO,OAAP,KAAoB,QAAxB,EAAkC;MAC9B,MAAM,CAAC,kBAAP,CAA0B,6BAA1B,EAAyD,aAAzD,EAAwE,WAAxE;IACH;EAEJ,CARD,MAQO,IAAI,SAAS,IAAI,CAAC,WAAW,CAAC,SAAD,CAAzB,IAAwC,SAAS,CAAC,CAAV,GAAc,EAA1D,EAA8D;IACjE;IACA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,SAAS,CAAC,CAAV,GAAc,EAAf,IAAqB,CAAhC,CAAV;EACH,CAvC0E,CAyC3E;;;EACA,IAAI,OAAO,KAAK,CAAhB,EAAmB;IACf,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,OAAD,CAAhB,EADe,CACa;;IAC5B,GAAG,CAAC,IAAJ,CAAS,IAAT;IACA,GAAG,CAAC,IAAJ,CAAS,IAAT;EACH,CA9C0E,CAgD3E;;;EACA,IAAI,CAAC,SAAL,EAAgB;IACZ,OAAO,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAP;EACH,CAnD0E,CAqD3E;EACA;;;EACA,MAAM,GAAG,GAAG,cAAc,CAAC,SAAD,CAA1B,CAvD2E,CAyD3E;;EACA,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,aAAjB;;EACA,IAAI,OAAO,KAAK,CAAhB,EAAmB;IACf,GAAG,CAAC,GAAJ;IACA,GAAG,CAAC,GAAJ;IACA,GAAG,CAAC,GAAJ;IACA,CAAC,IAAI,OAAO,GAAG,CAAV,GAAc,CAAnB,CAJe,CAMf;;IACA,IAAI,GAAG,CAAC,CAAJ,GAAQ,EAAR,IAAc,GAAG,CAAC,CAAJ,KAAU,CAA5B,EAA+B;MAC1B,MAAM,CAAC,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmF,SAAnF;IACJ;EACJ,CAVD,MAUO,IAAI,GAAG,CAAC,CAAJ,KAAU,CAAd,EAAiB;IACnB,MAAM,CAAC,kBAAP,CAA0B,0CAA1B,EAAsE,WAAtE,EAAmF,SAAnF;EACJ;;EAED,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,CAAD,CAAhB;EACA,GAAG,CAAC,IAAJ,CAAS,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAL,CAAT,CAAnB;EACA,GAAG,CAAC,IAAJ,CAAS,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAL,CAAT,CAAnB;EAEA,OAAO,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAP;AACH;;AAED,OAAM,SAAU,SAAV,CAAoB,WAApB,EAAsD,SAAtD,EAA+E;EACjF;EACA,IAAI,WAAW,CAAC,IAAZ,IAAoB,IAApB,IAA4B,WAAW,CAAC,IAAZ,KAAqB,CAArD,EAAwD;IACpD,IAAI,WAAW,CAAC,UAAZ,IAA0B,IAA9B,EAAoC;MAChC,MAAM,CAAC,kBAAP,CAA0B,iEAA1B,EAA6F,aAA7F,EAA4G,WAA5G;IACH;;IACD,OAAO,UAAU,CAAC,WAAD,EAAc,SAAd,CAAjB;EACH,CAPgF,CASjF;;;EACA,QAAQ,WAAW,CAAC,IAApB;IACI,KAAK,CAAL;MACI,OAAO,iBAAiB,CAAC,WAAD,EAAc,SAAd,CAAxB;;IACJ,KAAK,CAAL;MACI,OAAO,iBAAiB,CAAC,WAAD,EAAc,SAAd,CAAxB;;IACJ;MACI;EANR;;EASA,OAAO,MAAM,CAAC,UAAP,CAAkB,iCAAkC,WAAW,CAAC,IAAK,EAArE,EAAyE,MAAM,CAAC,MAAP,CAAc,qBAAvF,EAA8G;IACjH,SAAS,EAAE,sBADsG;IAEjH,eAAe,EAAE,WAAW,CAAC;EAFoF,CAA9G,CAAP;AAIH;;AAED,SAAS,kBAAT,CAA4B,EAA5B,EAA6C,MAA7C,EAAoE,SAApE,EAAkH;EAC9G,IAAI;IACA,MAAM,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,CAAD,CAAP,CAAZ,CAAwB,QAAxB,EAAd;;IACA,IAAI,KAAK,KAAK,CAAV,IAAe,KAAK,KAAK,CAA7B,EAAgC;MAAE,MAAM,IAAI,KAAJ,CAAU,WAAV,CAAN;IAA+B;;IACjE,EAAE,CAAC,CAAH,GAAO,KAAP;EACH,CAJD,CAIE,OAAO,KAAP,EAAc;IACZ,MAAM,CAAC,kBAAP,CAA0B,mCAA1B,EAA+D,GAA/D,EAAoE,MAAM,CAAC,CAAD,CAA1E;EACH;;EAED,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAjB;EACA,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAjB;;EAEA,IAAI;IACA,MAAM,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC,EAAD,CAAV,CAAxB;IACA,EAAE,CAAC,IAAH,GAAU,cAAc,CAAC,MAAD,EAAS;MAAE,CAAC,EAAE,EAAE,CAAC,CAAR;MAAW,CAAC,EAAE,EAAE,CAAC,CAAjB;MAAoB,aAAa,EAAE,EAAE,CAAC;IAAtC,CAAT,CAAxB;EACH,CAHD,CAGE,OAAO,KAAP,EAAc,CAAG;AACtB;;AAED,SAAS,aAAT,CAAuB,OAAvB,EAA0C;EACtC,MAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,OAAO,CAAC,KAAR,CAAc,CAAd,CAAX,CAApB;;EAEA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,WAAW,CAAC,MAAZ,KAAuB,EAAvD,EAA2D;IACvD,MAAM,CAAC,kBAAP,CAA0B,iDAA1B,EAA6E,SAA7E,EAAwF,OAAO,CAAC,OAAD,CAA/F;EACH;;EAED,MAAM,oBAAoB,GAAG,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAzC;EACA,MAAM,YAAY,GAAG,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAjC;EACA,MAAM,EAAE,GAAgB;IACpB,IAAI,EAAmB,CADH;IAEpB,OAAO,EAAgB,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EAFH;IAGpB,KAAK,EAAkB,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EAHH;IAIpB,oBAAoB,EAAG,oBAJH;IAKpB,YAAY,EAAW,YALH;IAMpB,QAAQ,EAAe,IANH;IAOpB,QAAQ,EAAe,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAPf;IAQpB,EAAE,EAAqB,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ,CARhB;IASpB,KAAK,EAAkB,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CATf;IAUpB,IAAI,EAAmB,WAAW,CAAC,CAAD,CAVd;IAWpB,UAAU,EAAa,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ;EAXhB,CAAxB,CATsC,CAuBtC;;EACA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;IAAE,OAAO,EAAP;EAAY;;EAE5C,EAAE,CAAC,IAAH,GAAU,SAAS,CAAC,OAAD,CAAnB;;EAEA,kBAAkB,CAAC,EAAD,EAAK,WAAW,CAAC,KAAZ,CAAkB,CAAlB,CAAL,EAA2B,iBAA3B,CAAlB;;EAEA,OAAO,EAAP;AACH;;AAED,SAAS,aAAT,CAAuB,OAAvB,EAA0C;EACtC,MAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,OAAO,CAAC,KAAR,CAAc,CAAd,CAAX,CAApB;;EAEA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,WAAW,CAAC,MAAZ,KAAuB,EAAvD,EAA2D;IACvD,MAAM,CAAC,kBAAP,CAA0B,iDAA1B,EAA6E,SAA7E,EAAwF,OAAO,CAAC,OAAD,CAA/F;EACH;;EAED,MAAM,EAAE,GAAgB;IACpB,IAAI,EAAQ,CADQ;IAEpB,OAAO,EAAK,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EAFQ;IAGpB,KAAK,EAAO,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EAHQ;IAIpB,QAAQ,EAAI,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAJJ;IAKpB,QAAQ,EAAI,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CALJ;IAMpB,EAAE,EAAU,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ,CANL;IAOpB,KAAK,EAAO,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAPJ;IAQpB,IAAI,EAAQ,WAAW,CAAC,CAAD,CARH;IASpB,UAAU,EAAE,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ;EATL,CAAxB,CAPsC,CAmBtC;;EACA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;IAAE,OAAO,EAAP;EAAY;;EAE5C,EAAE,CAAC,IAAH,GAAU,SAAS,CAAC,OAAD,CAAnB;;EAEA,kBAAkB,CAAC,EAAD,EAAK,WAAW,CAAC,KAAZ,CAAkB,CAAlB,CAAL,EAA2B,iBAA3B,CAAlB;;EAEA,OAAO,EAAP;AACH,C,CAED;;;AACA,SAAS,MAAT,CAAgB,cAAhB,EAA0C;EACtC,MAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,cAAX,CAApB;;EAEA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,WAAW,CAAC,MAAZ,KAAuB,CAAvD,EAA0D;IACtD,MAAM,CAAC,kBAAP,CAA0B,yBAA1B,EAAqD,gBAArD,EAAuE,cAAvE;EACH;;EAED,MAAM,EAAE,GAAgB;IACpB,KAAK,EAAK,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAZ,CAA6B,QAA7B,EADU;IAEpB,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAFF;IAGpB,QAAQ,EAAE,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CAHF;IAIpB,EAAE,EAAQ,aAAa,CAAC,WAAW,CAAC,CAAD,CAAZ,CAJH;IAKpB,KAAK,EAAK,YAAY,CAAC,WAAW,CAAC,CAAD,CAAZ,CALF;IAMpB,IAAI,EAAM,WAAW,CAAC,CAAD,CAND;IAOpB,OAAO,EAAG;EAPU,CAAxB,CAPsC,CAiBtC;;EACA,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;IAAE,OAAO,EAAP;EAAY;;EAE5C,IAAI;IACA,EAAE,CAAC,CAAH,GAAO,SAAS,CAAC,IAAV,CAAe,WAAW,CAAC,CAAD,CAA1B,EAA+B,QAA/B,EAAP;EAEH,CAHD,CAGE,OAAO,KAAP,EAAc;IACZ;IACA,OAAO,EAAP;EACH;;EAED,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;EACA,EAAE,CAAC,CAAH,GAAO,UAAU,CAAC,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAjB;;EAEA,IAAI,SAAS,CAAC,IAAV,CAAe,EAAE,CAAC,CAAlB,EAAqB,MAArB,MAAiC,SAAS,CAAC,IAAV,CAAe,EAAE,CAAC,CAAlB,EAAqB,MAArB,EAArC,EAAoE;IAChE;IACA,EAAE,CAAC,OAAH,GAAa,EAAE,CAAC,CAAhB;IACA,EAAE,CAAC,CAAH,GAAO,CAAP;EAEH,CALD,MAKO;IACH;IAEA,EAAE,CAAC,OAAH,GAAa,IAAI,CAAC,KAAL,CAAW,CAAC,EAAE,CAAC,CAAH,GAAO,EAAR,IAAc,CAAzB,CAAb;;IACA,IAAI,EAAE,CAAC,OAAH,GAAa,CAAjB,EAAoB;MAAE,EAAE,CAAC,OAAH,GAAa,CAAb;IAAiB;;IAEvC,IAAI,aAAa,GAAG,EAAE,CAAC,CAAH,GAAO,EAA3B;IAEA,MAAM,GAAG,GAAG,WAAW,CAAC,KAAZ,CAAkB,CAAlB,EAAqB,CAArB,CAAZ;;IAEA,IAAI,EAAE,CAAC,OAAH,KAAe,CAAnB,EAAsB;MAClB,GAAG,CAAC,IAAJ,CAAS,OAAO,CAAC,EAAE,CAAC,OAAJ,CAAhB;MACA,GAAG,CAAC,IAAJ,CAAS,IAAT;MACA,GAAG,CAAC,IAAJ,CAAS,IAAT;MACA,aAAa,IAAI,EAAE,CAAC,OAAH,GAAa,CAAb,GAAiB,CAAlC;IACH;;IAED,MAAM,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,MAAJ,CAAW,GAAX,CAAD,CAAxB;;IACA,IAAI;MACA,EAAE,CAAC,IAAH,GAAU,cAAc,CAAC,MAAD,EAAS;QAAE,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAJ,CAAZ;QAAoB,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,CAAJ,CAA9B;QAAsC,aAAa,EAAE;MAArD,CAAT,CAAxB;IACH,CAFD,CAEE,OAAO,KAAP,EAAc,CAAG;;IAEnB,EAAE,CAAC,IAAH,GAAU,SAAS,CAAC,cAAD,CAAnB;EACH;;EAED,EAAE,CAAC,IAAH,GAAU,IAAV;EAEA,OAAO,EAAP;AACH;;AAGD,OAAM,SAAU,KAAV,CAAgB,cAAhB,EAAyC;EAC3C,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAD,CAAxB,CAD2C,CAG3C;;EACA,IAAI,OAAO,CAAC,CAAD,CAAP,GAAa,IAAjB,EAAuB;IAAE,OAAO,MAAM,CAAC,OAAD,CAAb;EAAyB,CAJP,CAM3C;;;EACA,QAAQ,OAAO,CAAC,CAAD,CAAf;IACI,KAAK,CAAL;MACI,OAAO,aAAa,CAAC,OAAD,CAApB;;IACJ,KAAK,CAAL;MACI,OAAO,aAAa,CAAC,OAAD,CAApB;;IACJ;MACI;EANR;;EASA,OAAO,MAAM,CAAC,UAAP,CAAkB,iCAAkC,OAAO,CAAC,CAAD,CAAI,EAA/D,EAAmE,MAAM,CAAC,MAAP,CAAc,qBAAjF,EAAwG;IAC3G,SAAS,EAAE,kBADgG;IAE3G,eAAe,EAAE,OAAO,CAAC,CAAD;EAFmF,CAAxG,CAAP;AAIH","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return Zero;\n    }\n    return BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nexport function computeAddress(key) {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nexport function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x01\", RLP.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    checkProperties(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = arrayify(hexlify(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push(hexlify(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n    return RLP.encode(raw);\n}\nexport function serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) { }\n}\nfunction _parseEip1559(payload) {\n    const transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = RLP.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) { }\n        tx.hash = keccak256(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nexport function parse(rawTransaction) {\n    const payload = arrayify(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}