{"ast":null,"code":"\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nvar BN = _BN.BN;\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n  return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === \"bigint\" || isBytes(value));\n} // Only warn about passing 10 into radix once\n\nlet _warnedToStringRadix = false;\nexport class BigNumber {\n  constructor(constructorGuard, hex) {\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new (BigNumber)\"\n      });\n    }\n\n    this._hex = hex;\n    this._isBigNumber = true;\n    Object.freeze(this);\n  }\n\n  fromTwos(value) {\n    return toBigNumber(toBN(this).fromTwos(value));\n  }\n\n  toTwos(value) {\n    return toBigNumber(toBN(this).toTwos(value));\n  }\n\n  abs() {\n    if (this._hex[0] === \"-\") {\n      return BigNumber.from(this._hex.substring(1));\n    }\n\n    return this;\n  }\n\n  add(other) {\n    return toBigNumber(toBN(this).add(toBN(other)));\n  }\n\n  sub(other) {\n    return toBigNumber(toBN(this).sub(toBN(other)));\n  }\n\n  div(other) {\n    const o = BigNumber.from(other);\n\n    if (o.isZero()) {\n      throwFault(\"division-by-zero\", \"div\");\n    }\n\n    return toBigNumber(toBN(this).div(toBN(other)));\n  }\n\n  mul(other) {\n    return toBigNumber(toBN(this).mul(toBN(other)));\n  }\n\n  mod(other) {\n    const value = toBN(other);\n\n    if (value.isNeg()) {\n      throwFault(\"division-by-zero\", \"mod\");\n    }\n\n    return toBigNumber(toBN(this).umod(value));\n  }\n\n  pow(other) {\n    const value = toBN(other);\n\n    if (value.isNeg()) {\n      throwFault(\"negative-power\", \"pow\");\n    }\n\n    return toBigNumber(toBN(this).pow(value));\n  }\n\n  and(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"and\");\n    }\n\n    return toBigNumber(toBN(this).and(value));\n  }\n\n  or(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"or\");\n    }\n\n    return toBigNumber(toBN(this).or(value));\n  }\n\n  xor(other) {\n    const value = toBN(other);\n\n    if (this.isNegative() || value.isNeg()) {\n      throwFault(\"unbound-bitwise-result\", \"xor\");\n    }\n\n    return toBigNumber(toBN(this).xor(value));\n  }\n\n  mask(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"mask\");\n    }\n\n    return toBigNumber(toBN(this).maskn(value));\n  }\n\n  shl(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shl\");\n    }\n\n    return toBigNumber(toBN(this).shln(value));\n  }\n\n  shr(value) {\n    if (this.isNegative() || value < 0) {\n      throwFault(\"negative-width\", \"shr\");\n    }\n\n    return toBigNumber(toBN(this).shrn(value));\n  }\n\n  eq(other) {\n    return toBN(this).eq(toBN(other));\n  }\n\n  lt(other) {\n    return toBN(this).lt(toBN(other));\n  }\n\n  lte(other) {\n    return toBN(this).lte(toBN(other));\n  }\n\n  gt(other) {\n    return toBN(this).gt(toBN(other));\n  }\n\n  gte(other) {\n    return toBN(this).gte(toBN(other));\n  }\n\n  isNegative() {\n    return this._hex[0] === \"-\";\n  }\n\n  isZero() {\n    return toBN(this).isZero();\n  }\n\n  toNumber() {\n    try {\n      return toBN(this).toNumber();\n    } catch (error) {\n      throwFault(\"overflow\", \"toNumber\", this.toString());\n    }\n\n    return null;\n  }\n\n  toBigInt() {\n    try {\n      return BigInt(this.toString());\n    } catch (e) {}\n\n    return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n      value: this.toString()\n    });\n  }\n\n  toString() {\n    // Lots of people expect this, which we do not support, so check (See: #889)\n    if (arguments.length > 0) {\n      if (arguments[0] === 10) {\n        if (!_warnedToStringRadix) {\n          _warnedToStringRadix = true;\n          logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n        }\n      } else if (arguments[0] === 16) {\n        logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      } else {\n        logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n      }\n    }\n\n    return toBN(this).toString(10);\n  }\n\n  toHexString() {\n    return this._hex;\n  }\n\n  toJSON(key) {\n    return {\n      type: \"BigNumber\",\n      hex: this.toHexString()\n    };\n  }\n\n  static from(value) {\n    if (value instanceof BigNumber) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      if (value.match(/^-?0x[0-9a-f]+$/i)) {\n        return new BigNumber(_constructorGuard, toHex(value));\n      }\n\n      if (value.match(/^-?[0-9]+$/)) {\n        return new BigNumber(_constructorGuard, toHex(new BN(value)));\n      }\n\n      return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n    }\n\n    if (typeof value === \"number\") {\n      if (value % 1) {\n        throwFault(\"underflow\", \"BigNumber.from\", value);\n      }\n\n      if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n        throwFault(\"overflow\", \"BigNumber.from\", value);\n      }\n\n      return BigNumber.from(String(value));\n    }\n\n    const anyValue = value;\n\n    if (typeof anyValue === \"bigint\") {\n      return BigNumber.from(anyValue.toString());\n    }\n\n    if (isBytes(anyValue)) {\n      return BigNumber.from(hexlify(anyValue));\n    }\n\n    if (anyValue) {\n      // Hexable interface (takes priority)\n      if (anyValue.toHexString) {\n        const hex = anyValue.toHexString();\n\n        if (typeof hex === \"string\") {\n          return BigNumber.from(hex);\n        }\n      } else {\n        // For now, handle legacy JSON-ified values (goes away in v6)\n        let hex = anyValue._hex; // New-form JSON\n\n        if (hex == null && anyValue.type === \"BigNumber\") {\n          hex = anyValue.hex;\n        }\n\n        if (typeof hex === \"string\") {\n          if (isHexString(hex) || hex[0] === \"-\" && isHexString(hex.substring(1))) {\n            return BigNumber.from(hex);\n          }\n        }\n      }\n    }\n\n    return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n  }\n\n  static isBigNumber(value) {\n    return !!(value && value._isBigNumber);\n  }\n\n} // Normalize the hex string\n\nfunction toHex(value) {\n  // For BN, call on the hex string\n  if (typeof value !== \"string\") {\n    return toHex(value.toString(16));\n  } // If negative, prepend the negative sign to the normalized positive value\n\n\n  if (value[0] === \"-\") {\n    // Strip off the negative sign\n    value = value.substring(1); // Cannot have multiple negative signs (e.g. \"--0x04\")\n\n    if (value[0] === \"-\") {\n      logger.throwArgumentError(\"invalid hex\", \"value\", value);\n    } // Call toHex on the positive component\n\n\n    value = toHex(value); // Do not allow \"-0x00\"\n\n    if (value === \"0x00\") {\n      return value;\n    } // Negate the value\n\n\n    return \"-\" + value;\n  } // Add a \"0x\" prefix if missing\n\n\n  if (value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  } // Normalize zero\n\n\n  if (value === \"0x\") {\n    return \"0x00\";\n  } // Make the string even length\n\n\n  if (value.length % 2) {\n    value = \"0x0\" + value.substring(2);\n  } // Trim to smallest even-length string\n\n\n  while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n    value = \"0x\" + value.substring(4);\n  }\n\n  return value;\n}\n\nfunction toBigNumber(value) {\n  return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value) {\n  const hex = BigNumber.from(value).toHexString();\n\n  if (hex[0] === \"-\") {\n    return new BN(\"-\" + hex.substring(3), 16);\n  }\n\n  return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault, operation, value) {\n  const params = {\n    fault: fault,\n    operation: operation\n  };\n\n  if (value != null) {\n    params.value = value;\n  }\n\n  return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n} // value should have no prefix\n\n\nexport function _base36To16(value) {\n  return new BN(value, 36).toString(16);\n} // value should have no prefix\n\nexport function _base16To36(value) {\n  return new BN(value, 16).toString(36);\n}","map":{"version":3,"sources":["../src.ts/bignumber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\nimport _BN from \"bn.js\";\nvar BN = _BN.BN;\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nexport class BigNumber {\n    constructor(constructorGuard, hex) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nexport function _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nexport function _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n//# sourceMappingURL=bignumber.js.map"]},"metadata":{},"sourceType":"module"}