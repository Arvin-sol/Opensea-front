{"ast":null,"code":"// The RLP format\n// Serialization and deserialization for the BytesTree type, under the following grammar:\n// | First byte | Meaning                                                                    |\n// | ---------- | -------------------------------------------------------------------------- |\n// | 0   to 127 | HEX(leaf)                                                                  |\n// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |\n// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 55) + HEX(length_of_leaf) + HEX(leaf) |\n// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |\n// | 248 to 255 | HEX(length_of_length_of_node + 128 + 55) + HEX(length_of_node) + HEX(node) |\nconst encode = tree => {\n  const padEven = str => str.length % 2 === 0 ? str : \"0\" + str;\n\n  const uint = num => padEven(num.toString(16));\n\n  const length = (len, add) => len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);\n\n  const dataTree = tree => {\n    if (typeof tree === \"string\") {\n      const hex = tree.slice(2);\n      const pre = hex.length != 2 || hex >= \"80\" ? length(hex.length / 2, 128) : \"\";\n      return pre + hex;\n    } else {\n      const hex = tree.map(dataTree).join(\"\");\n      const pre = length(hex.length / 2, 192);\n      return pre + hex;\n    }\n  };\n\n  return \"0x\" + dataTree(tree);\n};\n\nconst decode = hex => {\n  let i = 2;\n\n  const parseTree = () => {\n    if (i >= hex.length) throw \"\";\n    const head = hex.slice(i, i + 2);\n    return head < \"80\" ? (i += 2, \"0x\" + head) : head < \"c0\" ? parseHex() : parseList();\n  };\n\n  const parseLength = () => {\n    const len = parseInt(hex.slice(i, i += 2), 16) % 64;\n    return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);\n  };\n\n  const parseHex = () => {\n    const len = parseLength();\n    return \"0x\" + hex.slice(i, i += len * 2);\n  };\n\n  const parseList = () => {\n    const lim = parseLength() * 2 + i;\n    let list = [];\n\n    while (i < lim) list.push(parseTree());\n\n    return list;\n  };\n\n  try {\n    return parseTree();\n  } catch (e) {\n    return [];\n  }\n};\n\nmodule.exports = {\n  encode,\n  decode\n};","map":{"version":3,"names":["encode","tree","padEven","str","length","uint","num","toString","len","add","dataTree","hex","slice","pre","map","join","decode","i","parseTree","head","parseHex","parseList","parseLength","parseInt","lim","list","push","e","module","exports"],"sources":["C:/Users/Lenovo/Desktop/OpenSea web3/my-app/build/opensea-clone3/node_modules/eth-lib/lib/rlp.js"],"sourcesContent":["// The RLP format\n// Serialization and deserialization for the BytesTree type, under the following grammar:\n// | First byte | Meaning                                                                    |\n// | ---------- | -------------------------------------------------------------------------- |\n// | 0   to 127 | HEX(leaf)                                                                  |\n// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |\n// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 55) + HEX(length_of_leaf) + HEX(leaf) |\n// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |\n// | 248 to 255 | HEX(length_of_length_of_node + 128 + 55) + HEX(length_of_node) + HEX(node) |\n\nconst encode = tree => {\n  const padEven = str => str.length % 2 === 0 ? str : \"0\" + str;\n\n  const uint = num => padEven(num.toString(16));\n\n  const length = (len, add) => len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);\n\n  const dataTree = tree => {\n    if (typeof tree === \"string\") {\n      const hex = tree.slice(2);\n      const pre = hex.length != 2 || hex >= \"80\" ? length(hex.length / 2, 128) : \"\";\n      return pre + hex;\n    } else {\n      const hex = tree.map(dataTree).join(\"\");\n      const pre = length(hex.length / 2, 192);\n      return pre + hex;\n    }\n  };\n\n  return \"0x\" + dataTree(tree);\n};\n\nconst decode = hex => {\n  let i = 2;\n\n  const parseTree = () => {\n    if (i >= hex.length) throw \"\";\n    const head = hex.slice(i, i + 2);\n    return head < \"80\" ? (i += 2, \"0x\" + head) : head < \"c0\" ? parseHex() : parseList();\n  };\n\n  const parseLength = () => {\n    const len = parseInt(hex.slice(i, i += 2), 16) % 64;\n    return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);\n  };\n\n  const parseHex = () => {\n    const len = parseLength();\n    return \"0x\" + hex.slice(i, i += len * 2);\n  };\n\n  const parseList = () => {\n    const lim = parseLength() * 2 + i;\n    let list = [];\n    while (i < lim) list.push(parseTree());\n    return list;\n  };\n\n  try {\n    return parseTree();\n  } catch (e) {\n    return [];\n  }\n};\n\nmodule.exports = { encode, decode };"],"mappings":"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"},"metadata":{},"sourceType":"script"}