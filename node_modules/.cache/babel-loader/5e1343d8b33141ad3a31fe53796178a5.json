{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccessLists = exports.checkMaxInitCodeSize = void 0;\n\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nvar types_1 = require(\"./types\");\n\nfunction checkMaxInitCodeSize(common, length) {\n  if (length > common.param('vm', 'maxInitCodeSize')) {\n    throw new Error(\"the initcode size of this transaction is too large: it is \".concat(length, \" while the max is \").concat(common.param('vm', 'maxInitCodeSize')));\n  }\n}\n\nexports.checkMaxInitCodeSize = checkMaxInitCodeSize;\n\nvar AccessLists =\n/** @class */\nfunction () {\n  function AccessLists() {}\n\n  AccessLists.getAccessListData = function (accessList) {\n    var AccessListJSON;\n    var bufferAccessList;\n\n    if (accessList && (0, types_1.isAccessList)(accessList)) {\n      AccessListJSON = accessList;\n      var newAccessList = [];\n\n      for (var i = 0; i < accessList.length; i++) {\n        var item = accessList[i];\n        var addressBuffer = (0, ethereumjs_util_1.toBuffer)(item.address);\n        var storageItems = [];\n\n        for (var index = 0; index < item.storageKeys.length; index++) {\n          storageItems.push((0, ethereumjs_util_1.toBuffer)(item.storageKeys[index]));\n        }\n\n        newAccessList.push([addressBuffer, storageItems]);\n      }\n\n      bufferAccessList = newAccessList;\n    } else {\n      bufferAccessList = accessList !== null && accessList !== void 0 ? accessList : []; // build the JSON\n\n      var json = [];\n\n      for (var i = 0; i < bufferAccessList.length; i++) {\n        var data = bufferAccessList[i];\n        var address = (0, ethereumjs_util_1.bufferToHex)(data[0]);\n        var storageKeys = [];\n\n        for (var item = 0; item < data[1].length; item++) {\n          storageKeys.push((0, ethereumjs_util_1.bufferToHex)(data[1][item]));\n        }\n\n        var jsonItem = {\n          address: address,\n          storageKeys: storageKeys\n        };\n        json.push(jsonItem);\n      }\n\n      AccessListJSON = json;\n    }\n\n    return {\n      AccessListJSON: AccessListJSON,\n      accessList: bufferAccessList\n    };\n  };\n\n  AccessLists.verifyAccessList = function (accessList) {\n    for (var key = 0; key < accessList.length; key++) {\n      var accessListItem = accessList[key];\n      var address = accessListItem[0];\n      var storageSlots = accessListItem[1];\n\n      if (accessListItem[2] !== undefined) {\n        throw new Error('Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.');\n      }\n\n      if (address.length != 20) {\n        throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes');\n      }\n\n      for (var storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {\n        if (storageSlots[storageSlot].length != 32) {\n          throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes');\n        }\n      }\n    }\n  };\n\n  AccessLists.getAccessListJSON = function (accessList) {\n    var accessListJSON = [];\n\n    for (var index = 0; index < accessList.length; index++) {\n      var item = accessList[index];\n      var JSONItem = {\n        address: '0x' + (0, ethereumjs_util_1.setLengthLeft)(item[0], 20).toString('hex'),\n        storageKeys: []\n      };\n      var storageSlots = item[1];\n\n      for (var slot = 0; slot < storageSlots.length; slot++) {\n        var storageSlot = storageSlots[slot];\n        JSONItem.storageKeys.push('0x' + (0, ethereumjs_util_1.setLengthLeft)(storageSlot, 32).toString('hex'));\n      }\n\n      accessListJSON.push(JSONItem);\n    }\n\n    return accessListJSON;\n  };\n\n  AccessLists.getDataFeeEIP2930 = function (accessList, common) {\n    var accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost');\n    var accessListAddressCost = common.param('gasPrices', 'accessListAddressCost');\n    var slots = 0;\n\n    for (var index = 0; index < accessList.length; index++) {\n      var item = accessList[index];\n      var storageSlots = item[1];\n      slots += storageSlots.length;\n    }\n\n    var addresses = accessList.length;\n    return addresses * accessListAddressCost + slots * accessListStorageKeyCost;\n  };\n\n  return AccessLists;\n}();\n\nexports.AccessLists = AccessLists;","map":{"version":3,"sources":["../src/util.ts"],"names":[],"mappings":";;;;;;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,SAAgB,oBAAhB,CAAqC,MAArC,EAAqD,MAArD,EAAmE;EACjE,IAAI,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,EAAmB,iBAAnB,CAAb,EAAoD;IAClD,MAAM,IAAI,KAAJ,CACJ,6DAAA,MAAA,CAA6D,MAA7D,EAAmE,oBAAnE,EAAmE,MAAnE,CAAwF,MAAM,CAAC,KAAP,CACtF,IADsF,EAEtF,iBAFsF,CAAxF,CADI,CAAN;EAMD;AACF;;AATD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAWA,IAAA,WAAA;AAAA;AAAA,YAAA;EAAA,SAAA,WAAA,GAAA,CAiGC;;EAhGe,WAAA,CAAA,iBAAA,GAAd,UAAgC,UAAhC,EAAyE;IACvE,IAAI,cAAJ;IACA,IAAI,gBAAJ;;IACA,IAAI,UAAU,IAAI,CAAA,GAAA,OAAA,CAAA,YAAA,EAAa,UAAb,CAAlB,EAA4C;MAC1C,cAAc,GAAG,UAAjB;MACA,IAAM,aAAa,GAAqB,EAAxC;;MAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;QAC1C,IAAM,IAAI,GAAmB,UAAU,CAAC,CAAD,CAAvC;QACA,IAAM,aAAa,GAAG,CAAA,GAAA,iBAAA,CAAA,QAAA,EAAS,IAAI,CAAC,OAAd,CAAtB;QACA,IAAM,YAAY,GAAa,EAA/B;;QACA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,IAAI,CAAC,WAAL,CAAiB,MAA7C,EAAqD,KAAK,EAA1D,EAA8D;UAC5D,YAAY,CAAC,IAAb,CAAkB,CAAA,GAAA,iBAAA,CAAA,QAAA,EAAS,IAAI,CAAC,WAAL,CAAiB,KAAjB,CAAT,CAAlB;QACD;;QACD,aAAa,CAAC,IAAd,CAAmB,CAAC,aAAD,EAAgB,YAAhB,CAAnB;MACD;;MACD,gBAAgB,GAAG,aAAnB;IACD,CAdD,MAcO;MACL,gBAAgB,GAAG,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAA,UAAA,GAAc,EAAjC,CADK,CAEL;;MACA,IAAM,IAAI,GAAe,EAAzB;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,gBAAgB,CAAC,MAArC,EAA6C,CAAC,EAA9C,EAAkD;QAChD,IAAM,IAAI,GAAG,gBAAgB,CAAC,CAAD,CAA7B;QACA,IAAM,OAAO,GAAG,CAAA,GAAA,iBAAA,CAAA,WAAA,EAAY,IAAI,CAAC,CAAD,CAAhB,CAAhB;QACA,IAAM,WAAW,GAAa,EAA9B;;QACA,KAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAAlC,EAA0C,IAAI,EAA9C,EAAkD;UAChD,WAAW,CAAC,IAAZ,CAAiB,CAAA,GAAA,iBAAA,CAAA,WAAA,EAAY,IAAI,CAAC,CAAD,CAAJ,CAAQ,IAAR,CAAZ,CAAjB;QACD;;QACD,IAAM,QAAQ,GAAmB;UAC/B,OAAO,EAAA,OADwB;UAE/B,WAAW,EAAA;QAFoB,CAAjC;QAIA,IAAI,CAAC,IAAL,CAAU,QAAV;MACD;;MACD,cAAc,GAAG,IAAjB;IACD;;IAED,OAAO;MACL,cAAc,EAAA,cADT;MAEL,UAAU,EAAE;IAFP,CAAP;EAID,CAzCa;;EA2CA,WAAA,CAAA,gBAAA,GAAd,UAA+B,UAA/B,EAA2D;IACzD,KAAK,IAAI,GAAG,GAAG,CAAf,EAAkB,GAAG,GAAG,UAAU,CAAC,MAAnC,EAA2C,GAAG,EAA9C,EAAkD;MAChD,IAAM,cAAc,GAAG,UAAU,CAAC,GAAD,CAAjC;MACA,IAAM,OAAO,GAAW,cAAc,CAAC,CAAD,CAAtC;MACA,IAAM,YAAY,GAAa,cAAc,CAAC,CAAD,CAA7C;;MACA,IAAU,cAAe,CAAC,CAAD,CAAf,KAAuB,SAAjC,EAA4C;QAC1C,MAAM,IAAI,KAAJ,CACJ,sGADI,CAAN;MAGD;;MACD,IAAI,OAAO,CAAC,MAAR,IAAkB,EAAtB,EAA0B;QACxB,MAAM,IAAI,KAAJ,CAAU,iEAAV,CAAN;MACD;;MACD,KAAK,IAAI,WAAW,GAAG,CAAvB,EAA0B,WAAW,GAAG,YAAY,CAAC,MAArD,EAA6D,WAAW,EAAxE,EAA4E;QAC1E,IAAI,YAAY,CAAC,WAAD,CAAZ,CAA0B,MAA1B,IAAoC,EAAxC,EAA4C;UAC1C,MAAM,IAAI,KAAJ,CAAU,sEAAV,CAAN;QACD;MACF;IACF;EACF,CAnBa;;EAqBA,WAAA,CAAA,iBAAA,GAAd,UAAgC,UAAhC,EAA4D;IAC1D,IAAM,cAAc,GAAG,EAAvB;;IACA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,UAAU,CAAC,MAAvC,EAA+C,KAAK,EAApD,EAAwD;MACtD,IAAM,IAAI,GAAQ,UAAU,CAAC,KAAD,CAA5B;MACA,IAAM,QAAQ,GAAQ;QACpB,OAAO,EAAE,OAAO,CAAA,GAAA,iBAAA,CAAA,aAAA,EAAsB,IAAI,CAAC,CAAD,CAA1B,EAA+B,EAA/B,EAAmC,QAAnC,CAA4C,KAA5C,CADI;QAEpB,WAAW,EAAE;MAFO,CAAtB;MAIA,IAAM,YAAY,GAAa,IAAI,CAAC,CAAD,CAAnC;;MACA,KAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,YAAY,CAAC,MAAvC,EAA+C,IAAI,EAAnD,EAAuD;QACrD,IAAM,WAAW,GAAG,YAAY,CAAC,IAAD,CAAhC;QACA,QAAQ,CAAC,WAAT,CAAqB,IAArB,CAA0B,OAAO,CAAA,GAAA,iBAAA,CAAA,aAAA,EAAc,WAAd,EAA2B,EAA3B,EAA+B,QAA/B,CAAwC,KAAxC,CAAjC;MACD;;MACD,cAAc,CAAC,IAAf,CAAoB,QAApB;IACD;;IACD,OAAO,cAAP;EACD,CAhBa;;EAkBA,WAAA,CAAA,iBAAA,GAAd,UAAgC,UAAhC,EAA8D,MAA9D,EAA4E;IAC1E,IAAM,wBAAwB,GAAG,MAAM,CAAC,KAAP,CAAa,WAAb,EAA0B,0BAA1B,CAAjC;IACA,IAAM,qBAAqB,GAAG,MAAM,CAAC,KAAP,CAAa,WAAb,EAA0B,uBAA1B,CAA9B;IAEA,IAAI,KAAK,GAAG,CAAZ;;IACA,KAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,UAAU,CAAC,MAAvC,EAA+C,KAAK,EAApD,EAAwD;MACtD,IAAM,IAAI,GAAG,UAAU,CAAC,KAAD,CAAvB;MACA,IAAM,YAAY,GAAG,IAAI,CAAC,CAAD,CAAzB;MACA,KAAK,IAAI,YAAY,CAAC,MAAtB;IACD;;IAED,IAAM,SAAS,GAAG,UAAU,CAAC,MAA7B;IACA,OAAO,SAAS,GAAG,qBAAZ,GAAoC,KAAK,GAAG,wBAAnD;EACD,CAba;;EAchB,OAAA,WAAA;AAAC,CAjGD,EAAA;;AAAa,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AccessLists = exports.checkMaxInitCodeSize = void 0;\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar types_1 = require(\"./types\");\nfunction checkMaxInitCodeSize(common, length) {\n    if (length > common.param('vm', 'maxInitCodeSize')) {\n        throw new Error(\"the initcode size of this transaction is too large: it is \".concat(length, \" while the max is \").concat(common.param('vm', 'maxInitCodeSize')));\n    }\n}\nexports.checkMaxInitCodeSize = checkMaxInitCodeSize;\nvar AccessLists = /** @class */ (function () {\n    function AccessLists() {\n    }\n    AccessLists.getAccessListData = function (accessList) {\n        var AccessListJSON;\n        var bufferAccessList;\n        if (accessList && (0, types_1.isAccessList)(accessList)) {\n            AccessListJSON = accessList;\n            var newAccessList = [];\n            for (var i = 0; i < accessList.length; i++) {\n                var item = accessList[i];\n                var addressBuffer = (0, ethereumjs_util_1.toBuffer)(item.address);\n                var storageItems = [];\n                for (var index = 0; index < item.storageKeys.length; index++) {\n                    storageItems.push((0, ethereumjs_util_1.toBuffer)(item.storageKeys[index]));\n                }\n                newAccessList.push([addressBuffer, storageItems]);\n            }\n            bufferAccessList = newAccessList;\n        }\n        else {\n            bufferAccessList = accessList !== null && accessList !== void 0 ? accessList : [];\n            // build the JSON\n            var json = [];\n            for (var i = 0; i < bufferAccessList.length; i++) {\n                var data = bufferAccessList[i];\n                var address = (0, ethereumjs_util_1.bufferToHex)(data[0]);\n                var storageKeys = [];\n                for (var item = 0; item < data[1].length; item++) {\n                    storageKeys.push((0, ethereumjs_util_1.bufferToHex)(data[1][item]));\n                }\n                var jsonItem = {\n                    address: address,\n                    storageKeys: storageKeys,\n                };\n                json.push(jsonItem);\n            }\n            AccessListJSON = json;\n        }\n        return {\n            AccessListJSON: AccessListJSON,\n            accessList: bufferAccessList,\n        };\n    };\n    AccessLists.verifyAccessList = function (accessList) {\n        for (var key = 0; key < accessList.length; key++) {\n            var accessListItem = accessList[key];\n            var address = accessListItem[0];\n            var storageSlots = accessListItem[1];\n            if (accessListItem[2] !== undefined) {\n                throw new Error('Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.');\n            }\n            if (address.length != 20) {\n                throw new Error('Invalid EIP-2930 transaction: address length should be 20 bytes');\n            }\n            for (var storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {\n                if (storageSlots[storageSlot].length != 32) {\n                    throw new Error('Invalid EIP-2930 transaction: storage slot length should be 32 bytes');\n                }\n            }\n        }\n    };\n    AccessLists.getAccessListJSON = function (accessList) {\n        var accessListJSON = [];\n        for (var index = 0; index < accessList.length; index++) {\n            var item = accessList[index];\n            var JSONItem = {\n                address: '0x' + (0, ethereumjs_util_1.setLengthLeft)(item[0], 20).toString('hex'),\n                storageKeys: [],\n            };\n            var storageSlots = item[1];\n            for (var slot = 0; slot < storageSlots.length; slot++) {\n                var storageSlot = storageSlots[slot];\n                JSONItem.storageKeys.push('0x' + (0, ethereumjs_util_1.setLengthLeft)(storageSlot, 32).toString('hex'));\n            }\n            accessListJSON.push(JSONItem);\n        }\n        return accessListJSON;\n    };\n    AccessLists.getDataFeeEIP2930 = function (accessList, common) {\n        var accessListStorageKeyCost = common.param('gasPrices', 'accessListStorageKeyCost');\n        var accessListAddressCost = common.param('gasPrices', 'accessListAddressCost');\n        var slots = 0;\n        for (var index = 0; index < accessList.length; index++) {\n            var item = accessList[index];\n            var storageSlots = item[1];\n            slots += storageSlots.length;\n        }\n        var addresses = accessList.length;\n        return addresses * accessListAddressCost + slots * accessListStorageKeyCost;\n    };\n    return AccessLists;\n}());\nexports.AccessLists = AccessLists;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}