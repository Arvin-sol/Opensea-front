{"ast":null,"code":"\"use strict\"; // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n  constructor(coerceFunc) {\n    defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n  }\n\n  _getCoder(param) {\n    switch (param.baseType) {\n      case \"address\":\n        return new AddressCoder(param.name);\n\n      case \"bool\":\n        return new BooleanCoder(param.name);\n\n      case \"string\":\n        return new StringCoder(param.name);\n\n      case \"bytes\":\n        return new BytesCoder(param.name);\n\n      case \"array\":\n        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n\n      case \"tuple\":\n        return new TupleCoder((param.components || []).map(component => {\n          return this._getCoder(component);\n        }), param.name);\n\n      case \"\":\n        return new NullCoder(param.name);\n    } // u?int[0-9]*\n\n\n    let match = param.type.match(paramTypeNumber);\n\n    if (match) {\n      let size = parseInt(match[2] || \"256\");\n\n      if (size === 0 || size > 256 || size % 8 !== 0) {\n        logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n      }\n\n      return new NumberCoder(size / 8, match[1] === \"int\", param.name);\n    } // bytes[0-9]+\n\n\n    match = param.type.match(paramTypeBytes);\n\n    if (match) {\n      let size = parseInt(match[1]);\n\n      if (size === 0 || size > 32) {\n        logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n      }\n\n      return new FixedBytesCoder(size, param.name);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n  }\n\n  _getWordSize() {\n    return 32;\n  }\n\n  _getReader(data, allowLoose) {\n    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n  }\n\n  _getWriter() {\n    return new Writer(this._getWordSize());\n  }\n\n  getDefaultValue(types) {\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n    return coder.defaultValue();\n  }\n\n  encode(types, values) {\n    if (types.length !== values.length) {\n      logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n\n    const writer = this._getWriter();\n\n    coder.encode(writer, values);\n    return writer.data;\n  }\n\n  decode(types, data, loose) {\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n    return coder.decode(this._getReader(arrayify(data), loose));\n  }\n\n}\nexport const defaultAbiCoder = new AbiCoder();","map":{"version":3,"sources":["../src.ts/abi-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n    constructor(coerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\nexport const defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map"]},"metadata":{},"sourceType":"module"}