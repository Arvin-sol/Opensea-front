{"ast":null,"code":"/**\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\n * @module Multibase\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst constants = require('./constants');\n\nexports = module.exports = multibase;\nexports.encode = encode;\nexports.decode = decode;\nexports.isEncoded = isEncoded;\nexports.names = Object.freeze(Object.keys(constants.names));\nexports.codes = Object.freeze(Object.keys(constants.codes));\nconst errNotSupported = new Error('Unsupported encoding');\n/**\n * Create a new buffer with the multibase varint+code.\n *\n * @param {string|number} nameOrCode - The multibase name or code number.\n * @param {Buffer} buf - The data to be prefixed with multibase.\n * @memberof Multibase\n * @returns {Buffer}\n */\n\nfunction multibase(nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded buffer');\n  }\n\n  const base = getBase(nameOrCode);\n  const codeBuf = Buffer.from(base.code);\n  const name = base.name;\n  validEncode(name, buf);\n  return Buffer.concat([codeBuf, buf]);\n}\n/**\n * Encode data with the specified base and add the multibase prefix.\n *\n * @param {string|number} nameOrCode - The multibase name or code number.\n * @param {Buffer} buf - The data to be encoded.\n * @returns {Buffer}\n * @memberof Multibase\n */\n\n\nfunction encode(nameOrCode, buf) {\n  const base = getBase(nameOrCode);\n  const name = base.name;\n  return multibase(name, Buffer.from(base.encode(buf)));\n}\n/**\n * Takes a buffer or string encoded with multibase header, decodes it and\n * returns the decoded buffer\n *\n * @param {Buffer|string} bufOrString\n * @returns {Buffer}\n * @memberof Multibase\n *\n */\n\n\nfunction decode(bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString();\n  }\n\n  const code = bufOrString.substring(0, 1);\n  bufOrString = bufOrString.substring(1, bufOrString.length);\n\n  if (typeof bufOrString === 'string') {\n    bufOrString = Buffer.from(bufOrString);\n  }\n\n  const base = getBase(code);\n  return Buffer.from(base.decode(bufOrString.toString()));\n}\n/**\n * Is the given data multibase encoded?\n *\n * @param {Buffer|string} bufOrString\n * @returns {boolean}\n * @memberof Multibase\n */\n\n\nfunction isEncoded(bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString();\n  } // Ensure bufOrString is a string\n\n\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\n    return false;\n  }\n\n  const code = bufOrString.substring(0, 1);\n\n  try {\n    const base = getBase(code);\n    return base.name;\n  } catch (err) {\n    return false;\n  }\n}\n/**\n * @param {string} name\n * @param {Buffer} buf\n * @private\n * @returns {undefined}\n */\n\n\nfunction validEncode(name, buf) {\n  const base = getBase(name);\n  base.decode(buf.toString());\n}\n\nfunction getBase(nameOrCode) {\n  let base;\n\n  if (constants.names[nameOrCode]) {\n    base = constants.names[nameOrCode];\n  } else if (constants.codes[nameOrCode]) {\n    base = constants.codes[nameOrCode];\n  } else {\n    throw errNotSupported;\n  }\n\n  if (!base.isImplemented()) {\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet');\n  }\n\n  return base;\n}","map":{"version":3,"names":["Buffer","require","constants","exports","module","multibase","encode","decode","isEncoded","names","Object","freeze","keys","codes","errNotSupported","Error","nameOrCode","buf","base","getBase","codeBuf","from","code","name","validEncode","concat","bufOrString","isBuffer","toString","substring","length","prototype","call","err","isImplemented"],"sources":["C:/Users/Lenovo/Desktop/OpenSea web3/my-app/node_modules/cids/node_modules/multibase/src/index.js"],"sourcesContent":["/**\n * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.\n * @module Multibase\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst constants = require('./constants')\n\nexports = module.exports = multibase\nexports.encode = encode\nexports.decode = decode\nexports.isEncoded = isEncoded\nexports.names = Object.freeze(Object.keys(constants.names))\nexports.codes = Object.freeze(Object.keys(constants.codes))\n\nconst errNotSupported = new Error('Unsupported encoding')\n\n/**\n * Create a new buffer with the multibase varint+code.\n *\n * @param {string|number} nameOrCode - The multibase name or code number.\n * @param {Buffer} buf - The data to be prefixed with multibase.\n * @memberof Multibase\n * @returns {Buffer}\n */\nfunction multibase (nameOrCode, buf) {\n  if (!buf) {\n    throw new Error('requires an encoded buffer')\n  }\n  const base = getBase(nameOrCode)\n  const codeBuf = Buffer.from(base.code)\n\n  const name = base.name\n  validEncode(name, buf)\n  return Buffer.concat([codeBuf, buf])\n}\n\n/**\n * Encode data with the specified base and add the multibase prefix.\n *\n * @param {string|number} nameOrCode - The multibase name or code number.\n * @param {Buffer} buf - The data to be encoded.\n * @returns {Buffer}\n * @memberof Multibase\n */\nfunction encode (nameOrCode, buf) {\n  const base = getBase(nameOrCode)\n  const name = base.name\n\n  return multibase(name, Buffer.from(base.encode(buf)))\n}\n\n/**\n * Takes a buffer or string encoded with multibase header, decodes it and\n * returns the decoded buffer\n *\n * @param {Buffer|string} bufOrString\n * @returns {Buffer}\n * @memberof Multibase\n *\n */\nfunction decode (bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString()\n  }\n\n  const code = bufOrString.substring(0, 1)\n  bufOrString = bufOrString.substring(1, bufOrString.length)\n\n  if (typeof bufOrString === 'string') {\n    bufOrString = Buffer.from(bufOrString)\n  }\n\n  const base = getBase(code)\n  return Buffer.from(base.decode(bufOrString.toString()))\n}\n\n/**\n * Is the given data multibase encoded?\n *\n * @param {Buffer|string} bufOrString\n * @returns {boolean}\n * @memberof Multibase\n */\nfunction isEncoded (bufOrString) {\n  if (Buffer.isBuffer(bufOrString)) {\n    bufOrString = bufOrString.toString()\n  }\n\n  // Ensure bufOrString is a string\n  if (Object.prototype.toString.call(bufOrString) !== '[object String]') {\n    return false\n  }\n\n  const code = bufOrString.substring(0, 1)\n  try {\n    const base = getBase(code)\n    return base.name\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * @param {string} name\n * @param {Buffer} buf\n * @private\n * @returns {undefined}\n */\nfunction validEncode (name, buf) {\n  const base = getBase(name)\n  base.decode(buf.toString())\n}\n\nfunction getBase (nameOrCode) {\n  let base\n\n  if (constants.names[nameOrCode]) {\n    base = constants.names[nameOrCode]\n  } else if (constants.codes[nameOrCode]) {\n    base = constants.codes[nameOrCode]\n  } else {\n    throw errNotSupported\n  }\n\n  if (!base.isImplemented()) {\n    throw new Error('Base ' + nameOrCode + ' is not implemented yet')\n  }\n\n  return base\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}