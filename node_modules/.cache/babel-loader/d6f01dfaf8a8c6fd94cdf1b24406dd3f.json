{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst mh = require('multihashes');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec');\n\nconst codecs = require('multicodec/src/base-table.json');\n\nconst CIDUtil = require('./cid-util');\n\nconst withIs = require('class-is');\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\n\n\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Buffer|CID} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor(version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash); // Default guard for when a CID < 0.7 is passed with no multibaseName\n\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version);\n\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version);\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n\n    if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1);\n      const v = parseInt(firstByte.toString('hex'), 16);\n\n      if (v === 1) {\n        // version is a CID buffer\n        const cid = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      return;\n    } // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n\n\n    this.version = version;\n    /**\n     * @type {string}\n     */\n\n    this.codec = codec;\n    /**\n     * @type {Buffer}\n     */\n\n    this.multihash = multihash;\n    /**\n     * @type {string}\n     */\n\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n\n\n  get buffer() {\n    let buffer = this._buffer;\n\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash;\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n      } else {\n        throw new Error('unsupported version');\n      } // Cache this buffer so it doesn't have to be recreated\n\n\n      Object.defineProperty(this, '_buffer', {\n        value: buffer\n      });\n    }\n\n    return buffer;\n  }\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n\n\n  get prefix() {\n    return Buffer.concat([Buffer.from(`0${this.version}`, 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n  }\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n\n\n  toV0() {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n    }\n\n    const {\n      name,\n      length\n    } = mh.decode(this.multihash);\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n    }\n\n    return new _CID(0, this.codec, this.multihash);\n  }\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n\n\n  toV1() {\n    return new _CID(1, this.codec, this.multihash);\n  }\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n\n\n  toBaseEncodedString() {\n    let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n\n    if (this.string && base === this.multibaseName) {\n      return this.string;\n    }\n\n    let str = null;\n\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n      }\n\n      str = mh.toB58String(this.multihash);\n    } else if (this.version === 1) {\n      str = multibase.encode(base, this.buffer).toString();\n    } else {\n      throw new Error('unsupported version');\n    }\n\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', {\n        value: str\n      });\n    }\n\n    return str;\n  }\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {String}\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n\n  toString(base) {\n    return this.toBaseEncodedString(base);\n  }\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n\n\n  toJSON() {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    };\n  }\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n\n\n  equals(other) {\n    return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n  }\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n\n\n  static validateCID(other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other);\n\n    if (errorMsg) {\n      throw new Error(errorMsg);\n    }\n  }\n\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"names":["Buffer","require","mh","multibase","multicodec","codecs","CIDUtil","withIs","CID","constructor","version","codec","multihash","multibaseName","_CID","isCID","cid","from","baseName","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","validateCID","Object","defineProperty","value","isBuffer","firstByte","v","buffer","_buffer","concat","getCodeVarint","Error","prefix","toV0","name","length","toV1","toBaseEncodedString","base","string","str","toB58String","encode","Symbol","for","toJSON","hash","equals","other","errorMsg","checkCIDComponents","className","symbolName","module","exports"],"sources":["C:/Users/Lenovo/Desktop/OpenSea web3/my-app/build/opensea-clone3/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst codecs = require('multicodec/src/base-table.json')\nconst CIDUtil = require('./cid-util')\nconst withIs = require('class-is')\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Buffer|CID} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor (version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = Buffer.from(cid.multihash)\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\n      return\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version)\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version)\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = baseName\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = mh.fromB58String(version)\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      Object.defineProperty(this, 'string', { value: version })\n      return\n    }\n\n    if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1)\n      const v = parseInt(firstByte.toString('hex'), 16)\n      if (v === 1) {\n        // version is a CID buffer\n        const cid = version\n        this.version = v\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = 'base32'\n      } else {\n        // version is a raw multihash buffer, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = version\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      return\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n    this.version = version\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash\n\n    /**\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get buffer () {\n    let buffer = this._buffer\n\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([\n          Buffer.from('01', 'hex'),\n          multicodec.getCodeVarint(this.codec),\n          this.multihash\n        ])\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', { value: buffer })\n    }\n\n    return buffer\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n  get prefix () {\n    return Buffer.concat([\n      Buffer.from(`0${this.version}`, 'hex'),\n      multicodec.getCodeVarint(this.codec),\n      mh.prefix(this.multihash)\n    ])\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new _CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new _CID(1, this.codec, this.multihash)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base = this.multibaseName) {\n    if (this.string && base === this.multibaseName) {\n      return this.string\n    }\n    let str = null\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n      }\n      str = mh.toB58String(this.multihash)\n    } else if (this.version === 1) {\n      str = multibase.encode(base, this.buffer).toString()\n    } else {\n      throw new Error('unsupported version')\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', { value: str })\n    }\n    return str\n  }\n\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {String}\n   */\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return 'CID(' + this.toString() + ')'\n  }\n\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      this.multihash.equals(other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID (other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n})\n\n_CID.codecs = codecs\n\nmodule.exports = _CID\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}